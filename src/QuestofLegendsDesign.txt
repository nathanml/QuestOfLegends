Nathan Maher Levy
U53054148

CLASS STRUCTURE


1. GAME CLASSES

Board: Class holding board attributes and methods for the game

BoardGame: Abstract class with attributes shared by all board games. Implements Playable Interface

Fight: The Fight Class is called when monsters appear. This class initializes the instances of each monster and creates a random team of monsters matching the heroes level. Fight has a method startFight which runs the fight

Fightable: An interface holding methods shared by all classes that can participate in fights (heroes, monsters, teams etc.) These methods include damage, dodge, attack, winFight etc.

Main: Runs the game

Piece: Class for game pieces. The 3 main pieces used in the game are the hero piece ("X"), the market piece ("M"), and the NA piece ("N")

Playable: Interface for methods shared by all games. Has generateTeams() and playGame()

Player: Class for the player. A player is created when the game begins and has a team of heroes as well as a game piece. The player controls the movement of the game piece with the move() method

Quest: The class for the game itself. Generates the game board, pieces, and players. Extends the BoardGame class so it implements the playGame method which contains the logic for the game.

Sellable: Interface for methods shared by all items that can be bought and sold (e.g buyItem(), sellItem())

Team: Class for a Team. Teams consist of generic Characters (heroes or monsters). Team implements the fightable interface

Tile: Class for each tile on the board. Tiles must hold a piece and the hero piece must be able to move to all tiles except NA tiles

Wallet: Class for a wallet which holds the hero's money and updates the hero's money.


2. CHARACTER CLASSES

Character: Abstract class for attributes shared by all characters (hp, name, level). Implements the fightable interface since all characters can fight

Hero: Abstract class for heroes that extends Character. Heroes have name, mana, exp, hp, level, nextLevel(which holds the amount of exp necessary for the next level), and an inventory of potions, fire spells, ice spells, lightning spells, weapons, and armors (each stored as an ArrayList). Implements methods from fightable interface and contains the methods for the actions a hero can do during a fight (drinkPotion(), castSpell(), changeWeapon(), changeArmor(), attack()).
	Paladin: Extends Hero and implements abstract method levelUp() so that Paladins' favored skills are increased more.
			Garl_Glittergold, Sehanine_Moonbow, Solonor_Thelandira: Classes for individual Paladins with specified values hard-coded in. Extend Paladin
	Sorcerer: Extends Hero and implements abstract method levelUp() so that Sorcerer's favored skills are increased more.
			Rillifane_Rallathil, Segojan_Earthcaller, Skoraeus_Stonebones: Classes for individual Sorcerers with specified values hard-coded in. Extend Sorcerer
	Warrior: Extends Hero and implements abstract method levelUp() so that Warrior's favored skills are increased more.
			Flandal_Steelskin, Gaerdal_Ironhand, Muamman_Duathall: Classes for individual Warriors with specified values hard-coded in. Extend Warrior

Monster: Class for monsters that extends Character. In addition to character attributes, monsters have damage, defense, and dodge chance values. This class implements fight methods for monsters.

3. MARKET-RELATED CLASSES

Armor: Class for armor. Implements sellable methods. Breastplate, Full_Body_Armor, Platinum_Shield, Speed_Boots, and Wizard_Shield all extend this class with specified values hard-coded in.

Spell: Abstract class for spells. Contain damage, price, minimum level, mana cost, and a name and have abstract method castSpell.

FireSpell: Extends Spell, implements sellable methods and castSpell() method. BreathOfFire, FlameTornado, HeatWave, LavaCommet all extend this class with specified values hard-coded in.

IceSpell: Extends Spell, implements sellable methods and castSpell() emthod. ArcticStorm, FrostBlizzard, IceBlade, and SnowCannon all extend this class with specified values hard-coded in.

LightningSpell: Extends Spell, implements sellable methods and castSpell() emthod. ElectricArrows, LightningDagger, SparkNeedles, and ThunderBlast all extend this class with specified values hard-coded in.

Potion: Abstract class for potions. Implements the sellable methods and contains abstract method usePotion(). Ambrosia, HealingPotion, LuckElixir, MagicPotion, MermaidTears, and StrengthPotion all extend this class and implement the usePotion() method since all potions increase different attributes.

Weapon: Class for weapons that implements the sellable interface. All weapons have a name, price, minLevel, and damage. Axe, Bow, Dagger, Scythe, Shield, Sword, and TSword all extend this class with the specified values hard-coded in.

Market: Abstract class for Markets. Markets have a currentPlayer whose team is in the market. They also all have an array of Sellables. This implements the method move() which runs when the heroes land on a market tile. It also has the abstract method sell for selling in each type of Market. Armory, FireMarket, IceMarket, LightningMarket, PotionMarket, and WeaponsMarket all extend the Market class with different values for the array of items. These classes also all implement the sell method inherited from market. GrandMarket also extends market but overrides the enter() method because the GrandMarket will allow the player to enter any of the markets.
